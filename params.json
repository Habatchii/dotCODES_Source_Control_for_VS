{"name":"Dotcodes source control for vs","tagline":"The dotCODES Source Control Maintenance Mainframe for Visual Studio","body":"dotCODES Specification Terminal\r\n\r\nThis document is an instructional manual for operating and maintenance of the dotCODES Specification Terminal. It lays out information to be used in installation and operating the prompts and its internal components.\r\n\r\nBelow is a general overview of the manual and the terminal's functions.\r\n\r\nDynamic and Discrete Logins \r\nOnboard Session\r\nTerminal Prompts and Consoles\r\nClass Directory\r\nOutput Types and Refactoring\r\nData Scaling\r\nEncapsulation and Packaging\r\nSystem Application Diagnostics and Exiting\r\n\r\nDynamic and Discrete Logins:\r\nThe two means of accessing the prompt's CLI environment are \r\nDynamic- Complete attribution of author\r\nTypically considered a human readable interface with advanced preferences for attribution and declaring classes.\r\nEstablishes complete access to runtimes and libraries.\r\nDynamically refactors and packages components built within the session.\r\nDiscrete- Robotic or automated access\r\nLimited access to preferences.\r\nEstablishes and conducts audits.\r\nDiscreetly references reports for printing.\r\n\r\nOnboard Session:\r\nThe process of accessing the prompt's CLI is called an onboard session. Each session is a distinct instance with concurrency via the session interface. Onboard sessions consist of one main board, called the dotCODES shell. Using shell access, a user may\r\nDispatch\r\nperform any of the session functions and runtimes located within the CLI. \r\nObfuscate\r\nEncapsulate data for use with different languages.\r\nTest\r\nConduct tests on the prompt's CLI.\r\nConstruct\r\nBuild new dotCODES components.\r\nOrganize\r\nArchive, copy and place files, folders and directories.\r\ndotCODES CGI\r\nOpen connections to repositories between directories and computers.\r\nEnd Session\r\nSystem Data\r\n\r\nTerminal Prompts and Consoles:\r\nEach session is an independent instance of the terminal, yet more than one prompt may be deployed. Prompts are one of three different CLI windows from which libraries and their properties may be utilized and maintained. Below is a listing of the three prompt windows:\r\n\r\nApplet Prompt\r\nUsed to compute small strings and document designs.\r\nRealtime Prompt\r\nUsed to execute more dense functions such as networking and media handling.\r\nBulkhead Prompt\r\nUsed to delegate enterprise grade features.\r\n\r\nEach Prompt type may be used to create Consoles, which are user defined containers that may be fitted with a virtual prompt and packaged as a deployable extension for dotCODES applications. They may include dotCODES runtime extensions, library extensions, source control extensions and other classes.\r\n\r\nClass Directory:\r\ndotCODES prompts use the dotCODES Class Directory as its default class library. It is built upon a C++ base and encapsulated in a Python extension. It hosts UNIX and Windows, respectfully and interprets other library files from other vendors. Below is a general layout of the directory:\r\n\r\ndotCODES Class Directory\r\n\r\nBracket Classes\r\nRepository Prompt Classes\r\nActor Classes\r\nNecessary Classes\r\nDefinitions\r\nOperator Classes\r\nNormal Web Services Classes\r\n\r\nBracket Classes-\r\nBrackets are the least common denominator for all dotCODES operations. They create container 'space' for all other elements and toolsets within the environment. Brackets are used to tag commands and functions that are used by the console during code completion or execution. They also help establish boundaries between major device families and their specifications.\r\nBelow are the seven brackets.\r\n\r\nSource Code IDE Bracket\r\nTerminal CLI Bracket\r\nAPI Bracket\r\nPC and Machinery Bracket\r\nLarge Mainframe Bracket\r\nEnvironmental Bracket\r\nSystem Bracket\r\n\r\nRepository Prompt Classes-\r\nRepository prompts distinguish the many different API schemes in which the console may use during completion or execution. A repository may be accessed, commits performed, peer notes exchanged and many other functions in which the API may allow.\r\n\r\nActor Classes-\r\nActors are the special words or commands used to build operations in which the console will complete or execute. They are registered in the console and called by the bracket that it is encapsulated within. An actor may be a basic word or an array of string commands.\r\n\r\nNecessary Classes-\r\nNecessaries are declarations that can be appended to a bracket without starting a new session or writing to the definitions classes. They may be used to bind two or more documents by transclusion. They may also create new prompts, actors and operations.\r\n\r\nDefinitions-\r\nDefinitions are used to build class identity and generally announce all instances of a class in the open console. Definitions must be announced before a session in order to complete or execute functions. \r\n\r\nOperator Classes-\r\nOperators perform any maintenance within the console. They typically are used by the console's syntax to write commands and operations along with actors and brackets. An example line using all three would be:\r\n[[T_ACT = \"copy all\"_\"place*directory/subdirectory\"_OPERA = \"close console\"]]\r\n\r\nThe above simply states: In the T bracket, use actors \"copy all\" and \"place\" to copy all files selected to the directory/subdirectory folder. The operator \"close console is used to complete the session.\r\n\r\nNormal Web Services Clasess (NWS)-\r\nNormal Web Services classes build anticipated normal connections between the console and any web enabled network. They are differentiated for developers seeking secure connections during sessions. The classes may be emphasized based upon their TLD, URL, Web Address, HTTP class or any other normal connection.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}